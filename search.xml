<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Prim-VS-Kruskal-Algorithm]]></title>
    <url>%2F2018%2F03%2F10%2FPrim-VS-Kruskal-Algorithm%2F</url>
    <content type="text"><![CDATA[最小生成树-Prim算法和Kruskal算法 Prim算法 1.概览 普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。 2.算法简单描述 1).输入：一个加权连通图，其中顶点集合为V，边集合为E； 2).初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空； 3).重复下列操作，直到Vnew = V： a.在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）； b.将v加入集合Vnew中，将&lt;u, v&gt;边加入集合Enew中； 4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。 下面对算法的图例描述 3.简单证明prim算法 反证法：假设prim生成的不是最小生成树 1).设prim生成的树为G0 2).假设存在Gmin使得cost(Gmin)&lt;cost(G0) 则在Gmin中存在&lt;u,v&gt;不属于G0 3).将&lt;u,v&gt;加入G0中可得一个环，且&lt;u,v&gt;不是该环的最长边(这是因为&lt;u,v&gt;∈Gmin) 4).这与prim每次生成最短边矛盾 5).故假设不成立，命题得证. 4.算法代码实现(未检验) 复制代码 #define MAX 100000 #define VNUM 10+1 //这里没有ID为0的点,so id号范围1~10 int edge[VNUM][VNUM]={/输入的邻接矩阵/}; int lowcost[VNUM]={0}; //记录Vnew中每个点到V中邻接点的最短边 int addvnew[VNUM]; //标记某点是否加入Vnew int adjecent[VNUM]={0}; //记录V中与Vnew最邻近的点 void prim(int start) { int sumweight=0; int i,j,k=0; for(i=1;i&lt;VNUM;i++) //顶点是从1开始 { lowcost[i]=edge[start][i]; addvnew[i]=-1; //将所有点至于Vnew之外,V之内，这里只要对应的为-1，就表示在Vnew之外 } addvnew[start]=0; //将起始点start加入Vnew adjecent[start]=start; for(i=1;i&lt;VNUM-1;i++) { int min=MAX; int v=-1; for(j=1;j&lt;VNUM;j++) { if(addvnew[j]!=-1&amp;&amp;lowcost[j]&lt;min) //在Vnew之外寻找最短路径 { min=lowcost[j]; v=j; } } if(v!=-1) { printf(&quot;%d %d %d\n&quot;,adjecent[v],v,lowcost[v]); addvnew[v]=0; //将v加Vnew中 sumweight+=lowcost[v]; //计算路径长度之和 for(j=1;j&lt;VNUM;j++) { if(addvnew[j]==-1&amp;&amp;edge[v][j]&lt;lowcost[j]) { lowcost[j]=edge[v][j]; //此时v点加入Vnew 需要更新lowcost adjecent[j]=v; } } } } printf(“the minmum weight is %d”,sumweight); } 复制代码 5.时间复杂度 这里记顶点数v，边数e 邻接矩阵:O(v2) 邻接表:O(elog2v) Kruskal算法 1.概览 Kruskal算法是一种用来寻找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪婪算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。 2.算法简单描述 1).记Graph中有v个顶点，e个边 2).新建图Graphnew，Graphnew中拥有原图中相同的e个顶点，但没有边 3).将原图Graph中所有e个边按权值从小到大排序 4).循环：从权值最小的边开始遍历每条边 直至图Graph中所有的节点都在同一个连通分量中 if 这条边连接的两个节点于图Graphnew中不在同一个连通分量中 添加这条边到图Graphnew中 图例描述： 3.简单证明Kruskal算法 对图的顶点数n做归纳，证明Kruskal算法对任意n阶图适用。 归纳基础： n=1，显然能够找到最小生成树。 归纳过程： 假设Kruskal算法对n≤k阶图适用，那么，在k+1阶图G中，我们把最短边的两个端点a和b做一个合并操作，即把u与v合为一个点v’，把原来接在u和v的边都接到v’上去，这样就能够得到一个k阶图G’(u,v的合并是k+1少一条边)，G’最小生成树T’可以用Kruskal算法得到。 我们证明T’+{&lt;u,v&gt;}是G的最小生成树。 用反证法，如果T’+{&lt;u,v&gt;}不是最小生成树，最小生成树是T，即W(T)&lt;W(T’+{&lt;u,v&gt;})。显然T应该包含&lt;u,v&gt;，否则，可以用&lt;u,v&gt;加入到T中，形成一个环，删除环上原有的任意一条边，形成一棵更小权值的生成树。而T-{&lt;u,v&gt;}，是G’的生成树。所以W(T-{&lt;u,v&gt;})&lt;=W(T’)，也就是W(T)&lt;=W(T’)+W(&lt;u,v&gt;)=W(T’+{&lt;u,v&gt;})，产生了矛盾。于是假设不成立，T’+{&lt;u,v&gt;}是G的最小生成树，Kruskal算法对k+1阶图也适用。 由数学归纳法，Kruskal算法得证。 4.代码算法实现 复制代码 typedef struct { char vertex[VertexNum]; //顶点表 int edges[VertexNum][VertexNum]; //邻接矩阵,可看做边表 int n,e; //图中当前的顶点数和边数 }MGraph; typedef struct node { int u; //边的起始顶点 int v; //边的终止顶点 int w; //边的权值 }Edge; void kruskal(MGraph G) { int i,j,u1,v1,sn1,sn2,k; int vset[VertexNum]; //辅助数组，判定两个顶点是否连通 int E[EdgeNum]; //存放所有的边 k=0; //E数组的下标从0开始 for (i=0;i&lt;G.n;i++) { for (j=0;j&lt;G.n;j++) { if (G.edges[i][j]!=0 &amp;&amp; G.edges[i][j]!=INF) { E[k].u=i; E[k].v=j; E[k].w=G.edges[i][j]; k++; } } } heapsort(E,k,sizeof(E[0])); //堆排序，按权值从小到大排列 for (i=0;i&lt;G.n;i++) //初始化辅助数组 { vset[i]=i; } k=1; //生成的边数，最后要刚好为总边数 j=0; //E中的下标 while (k&lt;G.n) { sn1=vset[E[j].u]; sn2=vset[E[j].v]; //得到两顶点属于的集合编号 if (sn1!=sn2) //不在同一集合编号内的话，把边加入最小生成树 { printf(&quot;%d —&gt; %d, %d&quot;,E[j].u,E[j].v,E[j].w); k++; for (i=0;i&lt;G.n;i++) { if (vset[i]==sn2) { vset[i]=sn1; } } } j++; } } 复制代码]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Prime</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Building a free github website step by step using HEXO]]></title>
    <url>%2F2018%2F03%2F05%2FBuild-a-free-github-website-step-by-step-using-HEXO%2F</url>
    <content type="text"><![CDATA[Install hexo following the instructions in https://hexo.io/docs/ hexo init hexo (Notice: cd the folder where you want to initiallize your hexo project first and then run the command above.) npm install hexo-deployer-git --save (This will create a public folder under your hexo project root) Go to your github and create a new repo the same name as your github name. (Notice: if you create a differnt name, it still works some kind of way, but will cause problems. For Example, my account name is ZheZhang007, after I created the repo, go to settings, you will see your website address is generated. For instance, mine is https://github.com/zhezhang007/zhezhang007.github.io) Copy the new repo’s address which is https://github.com/zhezhang007/zhezhang007.github.io.git (Notice: it has a postfix of git slightly different than your website link) Edit _config.yml file as shown in the screenshot (Notile, there are two kinds of _config.yml files, one is for the site, the other one is for the theme, go to the site one) hexo generate (This will complie all your hexo project files) hexo deploy (This will deploy all the compiled files to your github website according to your _config.yml setting)]]></content>
      <categories>
        <category>Settings</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CI in my eyes]]></title>
    <url>%2F2018%2F03%2F04%2FCI-in-my-eyes%2F</url>
    <content type="text"><![CDATA[CSU Channel Islands is a very beautiful campus. Photos shoot by me.]]></content>
      <categories>
        <category>Photography by me</category>
      </categories>
      <tags>
        <tag>campus</tag>
        <tag>beauty</tag>
        <tag>love</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Daily Schedule]]></title>
    <url>%2F2018%2F03%2F04%2FDaily-Schedule%2F</url>
    <content type="text"><![CDATA[Running a blog webite in a hacker way. I spend the whole weedkend to learn how to use Hexo. It is really awsome!!! I’m right now a second year Master of Computer Science student in United States. I made this Spring 2018 schedule just to fully use my time.]]></content>
      <categories>
        <category>Photography by me</category>
      </categories>
      <tags>
        <tag>schedule</tag>
      </tags>
  </entry>
</search>
